/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.facebook.research.asynchronousratchetingtree.art.message.thrift;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.facebook.thrift.*;
import com.facebook.thrift.async.*;
import com.facebook.thrift.meta_data.*;
import com.facebook.thrift.server.*;
import com.facebook.thrift.transport.*;
import com.facebook.thrift.protocol.*;

@SuppressWarnings({ "unused", "serial" })
public class SetupMessageStruct implements TBase, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("SetupMessageStruct");
  private static final TField LEAF_NUM_FIELD_DESC = new TField("leafNum", TType.I32, (short)1);
  private static final TField IDENTITIES_FIELD_DESC = new TField("identities", TType.LIST, (short)2);
  private static final TField EPHEMERAL_KEYS_FIELD_DESC = new TField("ephemeralKeys", TType.MAP, (short)3);
  private static final TField KEY_EXCHANGE_KEY_FIELD_DESC = new TField("keyExchangeKey", TType.STRING, (short)4);
  private static final TField TREE_FIELD_DESC = new TField("tree", TType.STRUCT, (short)5);

  public int leafNum;
  public List<String> identities;
  public Map<Integer,String> ephemeralKeys;
  public byte[] keyExchangeKey;
  public NodeStruct tree;
  public static final int LEAFNUM = 1;
  public static final int IDENTITIES = 2;
  public static final int EPHEMERALKEYS = 3;
  public static final int KEYEXCHANGEKEY = 4;
  public static final int TREE = 5;
  public static boolean DEFAULT_PRETTY_PRINT = true;

  // isset id assignments
  private static final int __LEAFNUM_ISSET_ID = 0;
  private BitSet __isset_bit_vector = new BitSet(1);

  public static final Map<Integer, FieldMetaData> metaDataMap;
  static {
    Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
    tmpMetaDataMap.put(LEAFNUM, new FieldMetaData("leafNum", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32)));
    tmpMetaDataMap.put(IDENTITIES, new FieldMetaData("identities", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new FieldValueMetaData(TType.STRING))));
    tmpMetaDataMap.put(EPHEMERALKEYS, new FieldMetaData("ephemeralKeys", TFieldRequirementType.DEFAULT, 
        new MapMetaData(TType.MAP, 
            new FieldValueMetaData(TType.I32), 
            new FieldValueMetaData(TType.STRING))));
    tmpMetaDataMap.put(KEYEXCHANGEKEY, new FieldMetaData("keyExchangeKey", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING)));
    tmpMetaDataMap.put(TREE, new FieldMetaData("tree", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, NodeStruct.class)));
    metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
  }

  static {
    FieldMetaData.addStructMetaDataMap(SetupMessageStruct.class, metaDataMap);
  }

  public SetupMessageStruct() {
  }

  public SetupMessageStruct(
    int leafNum,
    List<String> identities,
    Map<Integer,String> ephemeralKeys,
    byte[] keyExchangeKey,
    NodeStruct tree)
  {
    this();
    this.leafNum = leafNum;
    setLeafNumIsSet(true);
    this.identities = identities;
    this.ephemeralKeys = ephemeralKeys;
    this.keyExchangeKey = keyExchangeKey;
    this.tree = tree;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public SetupMessageStruct(SetupMessageStruct other) {
    __isset_bit_vector.clear();
    __isset_bit_vector.or(other.__isset_bit_vector);
    this.leafNum = TBaseHelper.deepCopy(other.leafNum);
    if (other.isSetIdentities()) {
      this.identities = TBaseHelper.deepCopy(other.identities);
    }
    if (other.isSetEphemeralKeys()) {
      this.ephemeralKeys = TBaseHelper.deepCopy(other.ephemeralKeys);
    }
    if (other.isSetKeyExchangeKey()) {
      this.keyExchangeKey = TBaseHelper.deepCopy(other.keyExchangeKey);
    }
    if (other.isSetTree()) {
      this.tree = TBaseHelper.deepCopy(other.tree);
    }
  }

  public SetupMessageStruct deepCopy() {
    return new SetupMessageStruct(this);
  }

  @Deprecated
  public SetupMessageStruct clone() {
    return new SetupMessageStruct(this);
  }

  public int  getLeafNum() {
    return this.leafNum;
  }

  public SetupMessageStruct setLeafNum(int leafNum) {
    this.leafNum = leafNum;
    setLeafNumIsSet(true);
    return this;
  }

  public void unsetLeafNum() {
    __isset_bit_vector.clear(__LEAFNUM_ISSET_ID);
  }

  // Returns true if field leafNum is set (has been assigned a value) and false otherwise
  public boolean isSetLeafNum() {
    return __isset_bit_vector.get(__LEAFNUM_ISSET_ID);
  }

  public void setLeafNumIsSet(boolean value) {
    __isset_bit_vector.set(__LEAFNUM_ISSET_ID, value);
  }

  public List<String>  getIdentities() {
    return this.identities;
  }

  public SetupMessageStruct setIdentities(List<String> identities) {
    this.identities = identities;
    return this;
  }

  public void unsetIdentities() {
    this.identities = null;
  }

  // Returns true if field identities is set (has been assigned a value) and false otherwise
  public boolean isSetIdentities() {
    return this.identities != null;
  }

  public void setIdentitiesIsSet(boolean value) {
    if (!value) {
      this.identities = null;
    }
  }

  public Map<Integer,String>  getEphemeralKeys() {
    return this.ephemeralKeys;
  }

  public SetupMessageStruct setEphemeralKeys(Map<Integer,String> ephemeralKeys) {
    this.ephemeralKeys = ephemeralKeys;
    return this;
  }

  public void unsetEphemeralKeys() {
    this.ephemeralKeys = null;
  }

  // Returns true if field ephemeralKeys is set (has been assigned a value) and false otherwise
  public boolean isSetEphemeralKeys() {
    return this.ephemeralKeys != null;
  }

  public void setEphemeralKeysIsSet(boolean value) {
    if (!value) {
      this.ephemeralKeys = null;
    }
  }

  public byte[]  getKeyExchangeKey() {
    return this.keyExchangeKey;
  }

  public SetupMessageStruct setKeyExchangeKey(byte[] keyExchangeKey) {
    this.keyExchangeKey = keyExchangeKey;
    return this;
  }

  public void unsetKeyExchangeKey() {
    this.keyExchangeKey = null;
  }

  // Returns true if field keyExchangeKey is set (has been assigned a value) and false otherwise
  public boolean isSetKeyExchangeKey() {
    return this.keyExchangeKey != null;
  }

  public void setKeyExchangeKeyIsSet(boolean value) {
    if (!value) {
      this.keyExchangeKey = null;
    }
  }

  public NodeStruct  getTree() {
    return this.tree;
  }

  public SetupMessageStruct setTree(NodeStruct tree) {
    this.tree = tree;
    return this;
  }

  public void unsetTree() {
    this.tree = null;
  }

  // Returns true if field tree is set (has been assigned a value) and false otherwise
  public boolean isSetTree() {
    return this.tree != null;
  }

  public void setTreeIsSet(boolean value) {
    if (!value) {
      this.tree = null;
    }
  }

  @SuppressWarnings("unchecked")
  public void setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
    case LEAFNUM:
      if (value == null) {
        unsetLeafNum();
      } else {
        setLeafNum((Integer)value);
      }
      break;

    case IDENTITIES:
      if (value == null) {
        unsetIdentities();
      } else {
        setIdentities((List<String>)value);
      }
      break;

    case EPHEMERALKEYS:
      if (value == null) {
        unsetEphemeralKeys();
      } else {
        setEphemeralKeys((Map<Integer,String>)value);
      }
      break;

    case KEYEXCHANGEKEY:
      if (value == null) {
        unsetKeyExchangeKey();
      } else {
        setKeyExchangeKey((byte[])value);
      }
      break;

    case TREE:
      if (value == null) {
        unsetTree();
      } else {
        setTree((NodeStruct)value);
      }
      break;

    default:
      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
    }
  }

  public Object getFieldValue(int fieldID) {
    switch (fieldID) {
    case LEAFNUM:
      return new Integer(getLeafNum());

    case IDENTITIES:
      return getIdentities();

    case EPHEMERALKEYS:
      return getEphemeralKeys();

    case KEYEXCHANGEKEY:
      return getKeyExchangeKey();

    case TREE:
      return getTree();

    default:
      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public boolean isSet(int fieldID) {
    switch (fieldID) {
    case LEAFNUM:
      return isSetLeafNum();
    case IDENTITIES:
      return isSetIdentities();
    case EPHEMERALKEYS:
      return isSetEphemeralKeys();
    case KEYEXCHANGEKEY:
      return isSetKeyExchangeKey();
    case TREE:
      return isSetTree();
    default:
      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
    }
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof SetupMessageStruct)
      return this.equals((SetupMessageStruct)that);
    return false;
  }

  public boolean equals(SetupMessageStruct that) {
    if (that == null)
      return false;
    if (this == that)
      return true;

    boolean this_present_leafNum = true;
    boolean that_present_leafNum = true;
    if (this_present_leafNum || that_present_leafNum) {
      if (!(this_present_leafNum && that_present_leafNum))
        return false;
      if (!TBaseHelper.equalsNobinary(this.leafNum, that.leafNum))
        return false;
    }

    boolean this_present_identities = true && this.isSetIdentities();
    boolean that_present_identities = true && that.isSetIdentities();
    if (this_present_identities || that_present_identities) {
      if (!(this_present_identities && that_present_identities))
        return false;
      if (!TBaseHelper.equalsNobinary(this.identities, that.identities))
        return false;
    }

    boolean this_present_ephemeralKeys = true && this.isSetEphemeralKeys();
    boolean that_present_ephemeralKeys = true && that.isSetEphemeralKeys();
    if (this_present_ephemeralKeys || that_present_ephemeralKeys) {
      if (!(this_present_ephemeralKeys && that_present_ephemeralKeys))
        return false;
      if (!TBaseHelper.equalsNobinary(this.ephemeralKeys, that.ephemeralKeys))
        return false;
    }

    boolean this_present_keyExchangeKey = true && this.isSetKeyExchangeKey();
    boolean that_present_keyExchangeKey = true && that.isSetKeyExchangeKey();
    if (this_present_keyExchangeKey || that_present_keyExchangeKey) {
      if (!(this_present_keyExchangeKey && that_present_keyExchangeKey))
        return false;
      if (!TBaseHelper.equalsSlow(this.keyExchangeKey, that.keyExchangeKey))
        return false;
    }

    boolean this_present_tree = true && this.isSetTree();
    boolean that_present_tree = true && that.isSetTree();
    if (this_present_tree || that_present_tree) {
      if (!(this_present_tree && that_present_tree))
        return false;
      if (!TBaseHelper.equalsNobinary(this.tree, that.tree))
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    return 0;
  }

  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin(metaDataMap);
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case LEAFNUM:
          if (field.type == TType.I32) {
            this.leafNum = iprot.readI32();
            setLeafNumIsSet(true);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IDENTITIES:
          if (field.type == TType.LIST) {
            {
              TList _list0 = iprot.readListBegin();
              this.identities = new ArrayList<String>(Math.max(0, _list0.size));
              for (int _i1 = 0; 
                   (_list0.size < 0) ? iprot.peekList() : (_i1 < _list0.size); 
                   ++_i1)
              {
                String _elem2;
                _elem2 = iprot.readString();
                this.identities.add(_elem2);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case EPHEMERALKEYS:
          if (field.type == TType.MAP) {
            {
              TMap _map3 = iprot.readMapBegin();
              this.ephemeralKeys = new HashMap<Integer,String>(Math.max(0, 2*_map3.size));
              for (int _i4 = 0; 
                   (_map3.size < 0) ? iprot.peekMap() : (_i4 < _map3.size); 
                   ++_i4)
              {
                int _key5;
                String _val6;
                _key5 = iprot.readI32();
                _val6 = iprot.readString();
                this.ephemeralKeys.put(_key5, _val6);
              }
              iprot.readMapEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case KEYEXCHANGEKEY:
          if (field.type == TType.STRING) {
            this.keyExchangeKey = iprot.readBinary();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TREE:
          if (field.type == TType.STRUCT) {
            this.tree = new NodeStruct();
            this.tree.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldBegin(LEAF_NUM_FIELD_DESC);
    oprot.writeI32(this.leafNum);
    oprot.writeFieldEnd();
    if (this.identities != null) {
      oprot.writeFieldBegin(IDENTITIES_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.identities.size()));
        for (String _iter7 : this.identities)        {
          oprot.writeString(_iter7);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.ephemeralKeys != null) {
      oprot.writeFieldBegin(EPHEMERAL_KEYS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.I32, TType.STRING, this.ephemeralKeys.size()));
        for (Map.Entry<Integer, String> _iter8 : this.ephemeralKeys.entrySet())        {
          oprot.writeI32(_iter8.getKey());
          oprot.writeString(_iter8.getValue());
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.keyExchangeKey != null) {
      oprot.writeFieldBegin(KEY_EXCHANGE_KEY_FIELD_DESC);
      oprot.writeBinary(this.keyExchangeKey);
      oprot.writeFieldEnd();
    }
    if (this.tree != null) {
      oprot.writeFieldBegin(TREE_FIELD_DESC);
      this.tree.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @Override
  public String toString() {
    return toString(DEFAULT_PRETTY_PRINT);
  }

  @Override
  public String toString(boolean prettyPrint) {
    return toString(1, prettyPrint);
  }

  @Override
  public String toString(int indent, boolean prettyPrint) {
    String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
    String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
    StringBuilder sb = new StringBuilder("SetupMessageStruct");
    sb.append(space);
    sb.append("(");
    sb.append(newLine);
    boolean first = true;

    sb.append(indentStr);
    sb.append("leafNum");
    sb.append(space);
    sb.append(":").append(space);
    sb.append(TBaseHelper.toString(this. getLeafNum(), indent + 1, prettyPrint));
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("identities");
    sb.append(space);
    sb.append(":").append(space);
    if (this. getIdentities() == null) {
      sb.append("null");
    } else {
      sb.append(TBaseHelper.toString(this. getIdentities(), indent + 1, prettyPrint));
    }
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("ephemeralKeys");
    sb.append(space);
    sb.append(":").append(space);
    if (this. getEphemeralKeys() == null) {
      sb.append("null");
    } else {
      sb.append(TBaseHelper.toString(this. getEphemeralKeys(), indent + 1, prettyPrint));
    }
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("keyExchangeKey");
    sb.append(space);
    sb.append(":").append(space);
    if (this. getKeyExchangeKey() == null) {
      sb.append("null");
    } else {
        int __keyExchangeKey_size = Math.min(this. getKeyExchangeKey().length, 128);
        for (int i = 0; i < __keyExchangeKey_size; i++) {
          if (i != 0) sb.append(" ");
          sb.append(Integer.toHexString(this. getKeyExchangeKey()[i]).length() > 1 ? Integer.toHexString(this. getKeyExchangeKey()[i]).substring(Integer.toHexString(this. getKeyExchangeKey()[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this. getKeyExchangeKey()[i]).toUpperCase());
        }
        if (this. getKeyExchangeKey().length > 128) sb.append(" ...");
    }
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("tree");
    sb.append(space);
    sb.append(":").append(space);
    if (this. getTree() == null) {
      sb.append("null");
    } else {
      sb.append(TBaseHelper.toString(this. getTree(), indent + 1, prettyPrint));
    }
    first = false;
    sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

